# Реализация Storage для SQLite

В проекте SSO реализован слой хранения данных на основе SQLite, который обеспечивает надежное и эффективное хранение информации о пользователях и приложениях. SQLite был выбран как легковесное и автономное решение, не требующее отдельного сервера базы данных.

Основной компонент хранения представлен структурой Storage, которая инкапсулирует всю логику работы с базой данных. При инициализации создается подключение к SQLite через стандартный интерфейс database/sql, что обеспечивает надежное управление соединениями и транзакциями. Путь к файлу базы данных передается через конфигурацию, что позволяет гибко настраивать расположение хранилища.

В системе реализованы основные операции для работы с пользователями. Метод SaveUser отвечает за сохранение новых пользователей в базе данных. При этом происходит проверка уникальности email-адреса, что предотвращает дублирование учетных записей. Пароли хранятся в хешированном виде, что обеспечивает безопасность данных даже в случае компрометации базы данных.

Для получения информации о пользователях реализован метод User, который по email-адресу возвращает полную информацию о пользователе, включая его идентификатор и хеш пароля. При отсутствии пользователя система возвращает специальную ошибку ErrUserNotFound, что позволяет корректно обрабатывать такие ситуации на уровне сервиса.

Особое внимание уделено работе с приложениями, которые могут использовать систему аутентификации. Метод App позволяет получить информацию о приложении по его идентификатору, включая имя и секретный ключ. Это необходимо для валидации запросов на аутентификацию и генерации токенов.

В системе также реализована проверка прав администратора через метод IsAdmin. Этот метод проверяет специальный флаг в таблице пользователей, что позволяет быстро определять права доступа без дополнительных запросов к базе данных. Такая реализация обеспечивает эффективную проверку прав при большом количестве запросов.

Важной особенностью реализации является обработка ошибок. Система определяет специальные типы ошибок, такие как ErrUserExists, ErrUserNotFound и ErrAppNotFound, что позволяет точно определять причину проблем и корректно обрабатывать их на уровне сервиса. Все ошибки логируются для последующего анализа.

Для обеспечения целостности данных в базе реализованы ограничения на уровне схемы. Email-адреса пользователей должны быть уникальными, что предотвращает создание дублирующихся учетных записей. Также определены правильные типы данных для всех полей, что обеспечивает корректное хранение информации.

Система поддерживает транзакционность операций, что гарантирует целостность данных при одновременном доступе. Это особенно важно при регистрации новых пользователей, где необходимо атомарно выполнить несколько операций. SQLite обеспечивает изоляцию транзакций на уровне базы данных.

Для оптимизации производительности используются подготовленные выражения (prepared statements), которые кэшируются и переиспользуются при повторных запросах. Это значительно снижает накладные расходы на компиляцию SQL-запросов и улучшает общую производительность системы.

В процессе работы с базой данных реализовано корректное закрытие соединений через метод Stop. Это обеспечивает освобождение ресурсов и предотвращает утечки памяти при завершении работы приложения. Также реализована обработка контекста для всех операций с базой данных, что позволяет корректно обрабатывать отмену операций.

Система хранения данных построена с учетом принципов чистой архитектуры, что обеспечивает абстракцию от конкретной реализации базы данных. Это позволяет в будущем легко заменить SQLite на другое хранилище данных, не затрагивая остальные компоненты системы. 